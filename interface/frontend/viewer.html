<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Adobe 1B Reader ‚Ä¢ Viewer</title>
  <link rel="stylesheet" href="/app/styles.css" />
  <!-- Adobe View SDK -->
  <script src="https://documentcloud.adobe.com/view-sdk/main.js"></script>
</head>
<body>
  <header>
    <div>Adobe Acrobat.Ai ‚Ä¢ Pdf Assistant</div>
    <div>
      <a href="/app/" class="link-back">‚Üê Back</a>
    </div>
  </header>

  <div class="viewer-container">
    <div class="pdf-wrapper">
      <div id="adobe-dc-view">
        <div id="loading-indicator">
          <div>
            <div>Loading Adobe PDF Viewer...</div>
            <div></div>
          </div>
        </div>
      </div>
      <div class="pdf-tools">
        <button class="btn-icon" id="btn-insights" title="Generate insights">üí°</button>
        
      </div>
    </div>

    <div class="side">

            <div class="card">
        <h3>Selected Text Recommendations</h3>
        <div class="card-header">
          <span class="selected-text-info" id="selected-text-info">No text selected</span>
          <div class="selection-controls">
            <button class="btn-clear" onclick="clearSelectedText()" title="Clear text selection" id="btn-clear-selection">üóëÔ∏è</button>
            <button class="btn-clear" onclick="generateTextRecommendations()" title="Generate recommendations" id="btn-text-recommendations" disabled>‚ñ∂</button>
            <button class="btn-clear" onclick="generateInsightsForSelectedText()" title="Generate insights" id = "btn-text-insights"disabled>üí°</button>
            <button class="btn-clear" id="btn-mic" title="Create podcast" disabled>üé§</button>
          </div>
        </div>
        <div class="help-text">
          <small>üí° <strong>Tip:</strong> Select text in the PDF to see insights and podcast buttons. Double-click outside to clear selection.</small>
        </div>
        <div id="text-recommendations" class="list"></div>
        <div id="recommendations-container"></div>
      </div>
       <div class="card" id="podcast-container">
  <h3>Podcast</h3>
  <div id="podcast-placeholder" class="loader-container">
    <span class="selected-text-info" id="selected-text-info">No Podcast Generated yet</span>
  </div>
</div>

      <div class="card">
        <h3>Persona & Job Recommendations</h3>
        <div class="card-header">
          
          <button class="btn-clear" onclick="generatePersonaRecommendations()" title="Generate recommendations" id = "personaBtn" disabled>üí°</button>
        </div>
        <div id="persona-recommendations" class="list"></div>
      </div>


      <div class="card">
        <div class="card-header">
          <h3>AI Insights</h3>
          <div class="annotation-count-container">
            
          </div>
        </div>
        <div id="insights" class="list"></div>
      </div>

    </div>
  </div>

  <div id="notification-container"></div>
 

  <script>
  /* -------------------- State / helpers -------------------- */
  const res = JSON.parse(sessionStorage.getItem('analysis_result') || '{}');
  const extractedTextEl = document.getElementById('extracted-text');
  const personaRecommendationsEl = document.getElementById('persona-recommendations');
  const textRecommendationsEl = document.getElementById('text-recommendations');
  const insightsEl = document.getElementById('insights');

  const personaInput = document.getElementById('persona');
  const persona = personaInput ? personaInput.value.trim() : '';
  sessionStorage.setItem('persona', persona || '');
  if (!sessionStorage.getItem('persona') && res && res.persona) {
  sessionStorage.setItem('persona', res.persona);
}


  console.log("Persona from sessionStorage:", sessionStorage.getItem('persona'));
console.log("Job from sessionStorage:", sessionStorage.getItem('job'));

  //toggling button for persona
  document.addEventListener("DOMContentLoaded", () => {
  const personaRaw = sessionStorage.getItem('persona');
  const jobRaw = sessionStorage.getItem('job');

  const persona = (personaRaw && personaRaw !== "null" && personaRaw !== "undefined")
    ? personaRaw.trim()
    : '';

  const job = (jobRaw && jobRaw !== "null" && jobRaw !== "undefined")
    ? jobRaw.trim()
    : '';

  const personaBtn = document.getElementById('personaBtn');
  const jobBtn = document.getElementById('btn-job-recommendations');

  if (personaBtn) personaBtn.disabled = persona === '';
  if (jobBtn) jobBtn.disabled = job === '';
});



    function waitForAdobeScript() {
    return new Promise((resolve, reject) => {
      if (typeof AdobeDC !== 'undefined') { adobeScriptReady = true; resolve(); return; }
      let attempts = 0;
      const intv = setInterval(() => {
        attempts++;
        if (typeof AdobeDC !== 'undefined') { adobeScriptReady = true; clearInterval(intv); resolve(); }
        else if (attempts >= 100) { clearInterval(intv); reject(new Error('Adobe SDK not loaded')); }
      }, 100);
    });
  }

  let adobeDCView = null;
  let adobeScriptReady = false;
  let pdfLoaded = false;
  let adobeApis = null;
  let adobeClientId = null;
  let currentAnnotations = [];
  let selectedText = "";


function showNotification(message, type = "success", timeout = 4000) {
  const container = document.getElementById("notification-container");
  if (!container) return;

  const toast = document.createElement("div");
  toast.className = `toast ${type}`;
  toast.textContent = message;

  container.appendChild(toast);

  // Auto remove after timeout
  setTimeout(() => {
    toast.style.opacity = "0";
    toast.style.transform = "translateY(20px)";
    setTimeout(() => toast.remove(), 300);
  }, timeout);
}

// Example usage
// showNotification("Background processing completed", "success");
// showNotification("Adobe APIs ready ‚úÖ", "info");
// showNotification("Something failed!", "error");

  function escapeForAttribute(s) {
    return String(s || '')
      .replace(/\\/g, '\\\\')
      .replace(/'/g, "\\'")
      .replace(/"/g, '\\"')
      .replace(/\r?\n/g, ' ');
  }

  function updateAnnotationCount() {
    const el = document.getElementById('annotation-count');
    if (!el) return;
    const c = currentAnnotations.length;
    el.textContent = `${c} highlight${c !== 1 ? 's' : ''}`;
    el.style.color = c > 0 ? '#4CAF50' : '#666';
  }

  async function loadAdobeConfig() {
    try {
      const r = await fetch('/api/config');
      const data = await r.json();
      adobeClientId = (data && data.adobe_api_key) || '';
      if (!adobeClientId) console.warn('ADOBE_API not set on server .env');
      return adobeClientId;
    } catch (e) {
      console.error('Failed to load /api/config', e);
      return null;
    }
  }

  async function initAdobeView(fileUrl) {
  const clientId = await loadAdobeConfig();
  if (!clientId) {
    showNotification("Adobe API Key missing!", "error");
    return;
  }

  await waitForAdobeScript(); // ‚úÖ ensure SDK loaded

  adobeDCView = new AdobeDC.View({
    clientId: adobeClientId,
    divId: "adobe-dc-view"   // ‚úÖ now matches HTML
  });

  const fileId = 'doc_' + btoa(fileUrl).replace(/=/g, '')

const previewFilePromise = adobeDCView.previewFile({
  content: { location: { url: fileUrl } },
  metaData: { fileName: "document.pdf", id: fileId }
}, { enableFilePreviewEvents: true });

previewFilePromise.then(adobeViewer => {
  // Get APIs
  adobeViewer.getAPIs().then(apis => {
    adobeApis = apis;
    pdfLoaded = true;
    showNotification("Adobe APIs ready ‚úÖ", "success");
  });
});

// Events ‚Üí attach to adobeDCView, not adobeViewer
// keep your existing EVENT_LISTENER setup
adobeDCView.registerCallback(
  AdobeDC.View.Enum.CallbackType.EVENT_LISTENER,
  async (event) => {
    if (!event || !event.type) return;

    switch (event.type) {
      case "DOCUMENT_OPEN":
        try {
          previewFilePromise.then(adobeViewer => {
            adobeViewer.getAPIs().then(apis => {
              adobeApis = apis;
              pdfLoaded = true;
              adobeScriptReady = true;
              showNotification("Adobe APIs ready ‚úÖ", "success");
            });
          });
        } catch (e) {
          console.error("Adobe API init failed:", e);
          showNotification("Adobe API init failed ‚ùå", "error");
        }
        break;

      case "PREVIEW_SELECTION_END":
  try {
    previewFilePromise.then(adobeViewer => {
      adobeViewer.getAPIs().then(apis => {
        apis.getSelectedContent()
          .then(result => {
            if (result && result.data && result.data.trim()) {
              selectedText = result.data.trim();
              updateSelectionUI();
              showNotification("Text selected!", "success");
            } else {
              clearSelectedText();
              showNotification("No text captured", "warning");
            }
          })
          .catch(err => {
            console.error("getSelectedContent() failed:", err);
            showNotification("Failed to fetch selection", "error");
          });
      });
    });
  } catch (e) {
    console.warn("Selection handler crashed:", e);
  }
  break;


      case "PREVIEW_SELECTION_CLEAR":
        clearSelectedText();
        break;

      default:
        // Ignore events that don‚Äôt have data we need
        console.debug("Adobe event:", event.type);
        break;
    }
  },
  {
    enableFilePreviewEvents: true,
    listenOn: ["DOCUMENT_OPEN", "PREVIEW_SELECTION_END", "PREVIEW_SELECTION_CLEAR"]
  }
);



  }



  function makeDocumentId(url) {
    return 'doc_' + String(url || '').replace(/[^a-zA-Z0-9]/g, '_').slice(-50);
  }

  /* -------------------- Rendering / Adobe init -------------------- */

  /* -------------------- Actions that use Adobe APIs -------------------- */
let currentPdfUrl = null;  // track currently rendered PDF

async function gotoSection(fileUrl, pageNumber) {
  try {
    // Ensure absolute URL (fileUrl is root-relative like "/uploads/xyz.pdf")
    const absUrl = window.location.origin + fileUrl;

    // Case 1: Same PDF already loaded ‚Üí just jump
    if (currentPdfUrl === absUrl && adobeApis) {
      if (typeof adobeApis.gotoLocation === "function") {
        await adobeApis.gotoLocation(pageNumber);
        showNotification("Jumped to page " + pageNumber, "success");
      } else {
        showNotification("gotoLocation API not available", "warning");
      }
      return;
    }

    // Case 2: Different PDF ‚Üí verify it exists before loading
    const headResp = await fetch(absUrl, { method: "HEAD" });
    if (!headResp.ok) {
      showNotification("PDF file not found: " + absUrl, "error");
      return;
    }

    // Load new PDF
    pdfLoaded = false;
    adobeApis = null;
    await initAdobeView(absUrl);
    currentPdfUrl = absUrl; // update tracker

    // Wait until PDF is loaded and APIs are ready
    let attempts = 0;
    while ((!pdfLoaded || !adobeApis) && attempts < 50) {
      await new Promise(resolve => setTimeout(resolve, 200));
      attempts++;
    }

    if (!pdfLoaded || !adobeApis) {
      showNotification("PDF not loaded yet. Please wait...", "warning");
      return;
    }

    // Jump after loading
    if (typeof adobeApis.gotoLocation === "function") {
      await adobeApis.gotoLocation(pageNumber);
      showNotification("Jumped to page " + pageNumber, "success");
    } else {
      showNotification("gotoLocation API not available", "warning");
    }
  } catch (e) {
    console.error("gotoSection failed:", e);
    showNotification("Failed to jump to section ‚ùå", "error");
  }
}


async function searchAndHighlight(searchText, pageNum) {
    try {
      const apis = await getAdobeAPIs();
      const results = await apis.search(searchText);
      const pageResults = results.filter(r => r.pageIndex === (pageNum - 1));
      if (pageResults.length) {
        await addHighlightAnnotation(pageResults[0], searchText);
      } else {
        showNotification('No results found', 'warning');
      }
    } catch (e) {
      console.error('Search failed:', e);
      showNotification('Search failed', 'error');
    }
  }

  async function highlightSection(sectionTitle, pageNum) {
    try {
      await waitForPDFReady();
      await jumpToPage(pageNum);
      setTimeout(() => searchAndHighlight(sectionTitle, pageNum), 600);
    } catch { showNotification('PDF not ready', 'warning'); }
  }

  async function highlightText(text, pageNum) {
    try {
      await waitForPDFReady();
      await jumpToPage(pageNum);
      setTimeout(() => searchAndHighlight(text, pageNum), 600);
    } catch { showNotification('PDF not ready', 'warning'); }
  }

  async function addHighlightAnnotation(searchResult, searchText) {
    try {
      await (await getAdobeAPIs()).addAnnotation({
        type: 'highlight',
        pageIndex: searchResult.pageIndex,
        rect: searchResult.rect,
        color: { red: 255, green: 255, blue: 0, alpha: 0.3 },
        author: 'Adobe 1B Reader',
        contents: `Highlighted: ${String(searchText).substring(0, 50)}...`
      });
      currentAnnotations.push(searchResult);
      updateAnnotationCount();
      showNotification('Highlight added', 'success');
    } catch { showNotification('Failed to add highlight', 'error'); }
  }

  async function clearAllAnnotations() {
    try {
      const apis = await getAdobeAPIs();
      await Promise.all(currentAnnotations.map(a => apis.deleteAnnotation(a).catch(() => {})));
      currentAnnotations = [];
      updateAnnotationCount();
      showNotification('All highlights cleared', 'success');
    } catch { showNotification('Failed to clear highlights', 'error'); }
  }

  /* -------------------- Selection helpers -------------------- */
  function updateSelectionUI() {
    const selectedTextInfo = document.getElementById('selected-text-info');
    const btnTextRecommendations = document.getElementById('btn-text-recommendations');
    const btnTextInsights = document.getElementById('btn-text-insights');
    const btnPodcast = document.getElementById('btn-mic');
    if (selectedText && selectedText.trim()) {
      if (selectedTextInfo) {
        selectedTextInfo.textContent = `Selected: "${selectedText.substring(0, 50)}${selectedText.length > 50 ? '...' : ''}"`;
        selectedTextInfo.style.color = '#4CAF50';
        selectedTextInfo.classList.add('has-selection');
      }
      if (btnTextRecommendations) btnTextRecommendations.disabled = false;
      if (btnTextInsights) btnTextInsights.disabled = false;
      if (btnPodcast) btnPodcast.disabled = false;
    } else {
      if (selectedTextInfo) {
        selectedTextInfo.textContent = 'No text selected';
        selectedTextInfo.style.color = '#666';
        selectedTextInfo.classList.remove('has-selection');
      }
      if (btnTextRecommendations) btnTextRecommendations.disabled = true;
      if (btnTextInsights) btnTextInsights.disabled = true;
      if (btnPodcast) btnPodcast.disabled = true;
    }
  }

  function clearSelectedText() {
    selectedText = "";
    updateSelectionUI();
    if (textRecommendationsEl) {
      textRecommendationsEl.innerHTML = '<div class="muted">No text selected for recommendations</div>';
    }
  }

  async function manualCheckSelection() {
    try {
      await initAdobeView();
      const selectedContent = await (await getAdobeAPIs()).getSelectedContent();
      if (selectedContent && selectedContent.text && selectedContent.text.trim()) {
        selectedText = selectedContent.text.trim();
        updateSelectionUI();
        showNotification('Selection captured', 'success');
      } else {
        clearSelectedText();
        showNotification('No text currently selected', 'info');
      }
    } catch (e) {
      console.error(e);
      showNotification('Failed to check selection', 'error');
    }
  }

  // simple status helpers for debugging
  function checkAdobeAPIsStatus() {
    const status = {
      adobeScriptReady,
      pdfLoaded,
      adobeApis: !!adobeApis,
      selectedText: selectedText ? selectedText.substring(0, 50) + '...' : 'None'
    };
    let message = 'Adobe APIs Status:\n';
    message += `‚Ä¢ Adobe Script: ${status.adobeScriptReady ? '‚úÖ Ready' : '‚ùå Not Ready'}\n`;
    message += `‚Ä¢ PDF Loaded: ${status.pdfLoaded ? '‚úÖ Yes' : '‚ùå No'}\n`;
    message += `‚Ä¢ Adobe APIs: ${status.adobeApis ? '‚úÖ Available' : '‚ùå Not Available'}\n`;
    message += `‚Ä¢ Selected Text: ${status.selectedText}`;
    alert(message);
    return status;
  }
  async function retryGetAdobeAPIs() {
    if (adobeApis) { showNotification('Adobe APIs already available', 'info'); return adobeApis; }
    showNotification('Please wait for VIEWER_READY to initialize APIs', 'info');
    return null;
  }
  async function testAdobeAPIs() {
    if (!adobeApis) { showNotification('APIs not ready', 'warning'); return false; }
    try {
      if (typeof adobeApis.getCurrentPage === 'function') {
        const pg = await adobeApis.getCurrentPage();
        console.log('Current page:', pg);
        showNotification('Adobe APIs OK', 'success');
        return true;
      }
      showNotification('Limited APIs available', 'warning');
      return false;
    } catch (e) {
      showNotification('APIs test failed', 'error');
      return false;
    }
  }

  /* -------------------- Recommendations / Insights / Podcast -------------------- */
function renderPersonaRecommendations(relatedSections) {
  if (!personaRecommendationsEl) return;
  personaRecommendationsEl.innerHTML = '';
  
  if (!relatedSections.length) {
    personaRecommendationsEl.innerHTML = '<div class="muted">No related sections found</div>';
    return;
  }

  relatedSections.forEach(group => {
    const src = group.source || {};
    const head = document.createElement('div');
    head.innerHTML = `<div><b>${escapeForAttribute(src.section_title || '')}</b> <span class="muted">(p.${src.page_number || 1})</span></div>`;
    personaRecommendationsEl.appendChild(head);

    (group.related || []).forEach(r => {
      const item = document.createElement('div');
      item.className = 'related-item';
      item.textContent = `‚Ü≥ ${r.section_title} (${r.document}, p.${r.page_number})`;

      // üëá Use gotoSection instead of renderPDF
      item.onclick = () => {
        const fileUrl = r.file_url ? r.file_url : ('/uploads/' + encodeURIComponent(r.document));
        gotoSection(fileUrl, r.page_number);
      };

      personaRecommendationsEl.appendChild(item);
    });
  });
}


function renderTextRecommendations(recs) {
  const container = document.getElementById("recommendations-container");
  if (!container) return;
  container.innerHTML = "";

  recs.forEach((rec, idx) => {
    const card = document.createElement("div");
    card.className = "recommendation-card";

    const title = document.createElement("h3");
    title.textContent = `#${idx + 1} ${rec.section_title}`;

    const meta = document.createElement("p");
    meta.innerHTML = `<em>${rec.document} (p.${rec.page_number})</em>`;

    const preview = document.createElement("p");
    preview.textContent = rec.content_preview;

    const sim = document.createElement("small");
    sim.textContent = `Similarity: ${(rec.similarity * 100).toFixed(1)}%`;

    const btn = document.createElement("button");
    btn.textContent = "Jump to Section";
btn.addEventListener("click", () => {
  gotoSection(rec.file_url, rec.page_number);
});

    card.append(title, meta, preview, sim, btn);
    container.appendChild(card);
  });
}



  async function generatePersonaRecommendations() {
    try {
      if (!res || !res.file_url) { showNotification('No document context', 'warning'); return; }
      showNotification('Generating persona recommendations...', 'info');

      const filename = (res.file_url.split('/').pop()) || '';
      const form = new FormData();
      form.append('filename', filename);
      form.append('text', '');
      if (res && res.metadata) {
        form.append('persona', res.metadata.persona || '');
        form.append('job_to_be_done', res.metadata.job_to_be_done || '');
      }
      const r = await fetch('/api/analyze', { method: 'POST', body: form });
      if (!r.ok) throw new Error('Failed');
      const data = await r.json();
      renderPersonaRecommendations(data.related_sections || []);
      showNotification('Persona recommendations ready', 'success');
    } catch (e) {
      console.error(e);
      showNotification('Failed to generate persona recommendations', 'error');
    }
  }

async function generateTextRecommendations() {
  try {
    if (!selectedText) {
      const t = prompt('Enter text to analyze:');
      if (!t || !t.trim()) { 
        showNotification('No text provided', 'warning'); 
        return; 
      }
      selectedText = t.trim();
      updateSelectionUI();
    }

    console.log("üëâ Sending to backend:", selectedText);

    showNotification('Generating text recommendations...', 'info');
    textRecommendationsEl.innerHTML = '<div class="muted">Loading...</div>'; // clear old

    const form = new FormData();
    form.append('selected_text', selectedText);
    if (res && res.metadata) {
      form.append('persona', res.metadata.persona || '');
      form.append('job_to_be_done', res.metadata.job_to_be_done || '');
    }

    const r = await fetch('/api/recommendations', { method: 'POST', body: form });
    if (!r.ok) throw new Error(await r.text());

    const data = await r.json();
    console.log("üëâ Backend returned:", data);

    renderTextRecommendations(data.recommendations || []);
    showNotification('Text recommendations ready', 'success');
  } catch (e) {
    console.error(e);
    showNotification('Failed to generate text recommendations', 'error');
  }
}


  async function generateInsightsPersona() {
  try {
    if (!res || !res.file_url) { 
      showNotification('No document context', 'warning'); 
      return; 
    }

    showNotification('Generating insights...', 'info');
    const filename = (res.file_url.split('/').pop()) || '';

    const form = new FormData();
    form.append('filename', filename);

    // Decide what text to send:
    let textToAnalyze = "";
    if (res && res.metadata && (res.metadata.persona || res.metadata.job_to_be_done)) {
      // Use persona & job_to_be_done context
      form.append('persona', res.metadata.persona || '');
      form.append('job_to_be_done', res.metadata.job_to_be_done || '');
    } else {
      // Fall back to selected text
      if (selectedText && selectedText.trim()) {
        textToAnalyze = selectedText.trim();
      }
    }

    form.append('text', textToAnalyze);

    const r = await fetch('/api/insights', { method: 'POST', body: form });
    if (!r.ok) throw new Error('Failed');
    const data = await r.json();

    renderInsights(data);
    showNotification('Insights ready', 'success');
  } catch (e) {
    console.error(e);
    showNotification('Failed to generate insights', 'error');
  }
}


  async function generatePodcast() {
    try {
      if (!res || !res.file_url) { showNotification('No document context', 'warning'); return; }
      showNotification('Creating podcast...', 'info');
      const filename = (res.file_url.split('/').pop()) || '';
      const form = new FormData();
      form.append('filename', filename);
      form.append('text', '');
      if (res && res.metadata) {
        form.append('persona', res.metadata.persona || '');
        form.append('job_to_be_done', res.metadata.job_to_be_done || '');
      }
      const r = await fetch('/api/podcast', { method: 'POST', body: form });
      if (!r.ok) throw new Error(await r.text());
      const data = await r.json();
      if (data && data.insights) renderInsights(data.insights);
      renderPodcast(data);
      showNotification('Podcast ready', 'success');
    } catch (e) { console.error(e); showNotification('Failed to create podcast', 'error'); }
  }

  function renderPodcast(data) {
  const side = document.querySelector('.side');
  // Clear loader if present
  const loader = document.getElementById("podcast-placeholder");
  if (loader) loader.remove();

  if (!data || !data.audio_url) return;
  const container = document.createElement('div');
  container.className = 'card';
  container.id = "podcast-card";

  const title = document.createElement('h3'); title.textContent = 'Podcast';
  const audio = document.createElement('audio'); 
  audio.controls = true; 
  audio.src = data.audio_url; 
  audio.style.width = '100%';

  const scriptEl = document.createElement('details');
  const sum = document.createElement('summary'); sum.textContent = 'Show script';
  const pre = document.createElement('pre'); pre.style.whiteSpace = 'pre-wrap'; pre.textContent = data.script || '';
  scriptEl.appendChild(sum); scriptEl.appendChild(pre);

  container.appendChild(title); 
  container.appendChild(audio); 
  container.appendChild(scriptEl);

  side && side.insertBefore(container, side.firstChild);

  try { audio.play().catch(()=>{}); } catch {}
}

function renderInsights(data) {
  hideLoading("insights"); // üëà clear loader

  if (!insightsEl) return;
  insightsEl.innerHTML = '';

  const groups = [
    { key: 'key_insights', title: 'Key Insights' },
    { key: 'did_you_know_facts', title: 'Did you know?' },
    { key: 'contradictions_or_counterpoints', title: 'Contradictions / Counterpoints' },
    { key: 'inspirations_or_connections', title: 'Inspirations / Connections' },
  ];

  groups.forEach(g => {
    const items = data && Array.isArray(data[g.key]) ? data[g.key] : [];
    const wrap = document.createElement('div'); wrap.className = 'insight-group';
    const h = document.createElement('div'); h.className = 'insight-title'; h.textContent = g.title; wrap.appendChild(h);
    const ul = document.createElement('ul'); ul.className = 'insight-list';
    items.forEach(t => { const li = document.createElement('li'); li.textContent = String(t); ul.appendChild(li); });
    if (!items.length) { const li = document.createElement('div'); li.className = 'muted'; li.textContent = 'No items'; wrap.appendChild(li); }
    else { wrap.appendChild(ul); }
    insightsEl.appendChild(wrap);
  });
}

  //Loading screen for Insights
  function showLoading(containerId, type = "spinner") {
  const container = document.getElementById(containerId);
  if (!container) return;

  container.innerHTML = ""; // clear old content

  const loader = document.createElement("div");
  loader.className = "loader";

  if (type === "spinner") {
    loader.innerHTML = `<div class="spinner"></div>`;
  } else if (type === "progress") {
    loader.innerHTML = `
      <div class="progress-bar">
        <div class="progress-bar-inner"></div>
      </div>`;
  }

  container.appendChild(loader);
}

function hideLoading(containerId) {
  const container = document.getElementById(containerId);
  if (!container) return;
  container.innerHTML = ""; // clear loader, ready for new content
}
  



async function generateInsightsForSelectedText() {
  if (!selectedText) { showNotification('No text selected for insights', 'warning'); return; }
  try {
    showLoading("insights", "spinner"); // üëà loader in Insights card

    const filename = (res.file_url.split('/').pop()) || '';
    const form = new FormData();
    form.append('filename', filename);
    form.append('text', selectedText);
    if (res && res.metadata) {
      form.append('persona', res.metadata.persona || '');
      form.append('job_to_be_done', res.metadata.job_to_be_done || '');
    }

    const r = await fetch('/api/insights', { method: 'POST', body: form });
    if (!r.ok) throw new Error(await r.text());
    const data = await r.json();

    renderInsights(data);
    showNotification('Insights ready for selected text', 'success');
  } catch (e) {
    console.error(e);
    hideLoading("insights");
    showNotification('Failed to generate insights', 'error');
  }
}

async function generatePodcastForSelectedText() {
  if (!selectedText) { showNotification('No text selected for podcast', 'warning'); return; }
  try {
    // Add loader at top of sidebar where podcast goes
    showLoading("podcast-placeholder", "progress");

    const filename = (res.file_url.split('/').pop()) || '';
    const form = new FormData();
    form.append('filename', filename);
    form.append('text', selectedText);
    if (res && res.metadata) {
      form.append('persona', res.metadata.persona || '');
      form.append('job_to_be_done', res.metadata.job_to_be_done || '');
    }

    const r = await fetch('/api/podcast', { method: 'POST', body: form });
    if (!r.ok) throw new Error(await r.text());
    const data = await r.json();

    if (data && data.insights) renderInsights(data.insights);
    renderPodcast(data);

    showNotification('Podcast ready for selected text', 'success');
  } catch (e) {
    console.error(e);
    hideLoading("podcast-placeholder");
    showNotification('Failed to create podcast', 'error');
  }
}



  function manualInputText() {
    const t = prompt('Enter the text you want to analyze:');
    if (t && t.trim()) { selectedText = t.trim(); updateSelectionUI(); showNotification('Text set manually', 'info'); }
    else { showNotification('No text entered', 'warning'); }
  }

  /* -------------------- Bootstrapping -------------------- */
  // Render extracted text list with jump/highlight buttons
  (res.subsection_analysis || []).forEach(txt => {
    const safeSnippet = escapeForAttribute(txt.refined_text || '');
    const page = txt.page_number || 1;
    const wrapper = document.createElement('div');
    wrapper.className = 'text-item';
    wrapper.innerHTML = `
      <div class="text-content">
        <div class="text-header"><b>${txt.document || ''}</b> <span class="muted">p.${page}</span></div>
        <div class="text-snippet">${txt.refined_text || ''}</div>
      </div>
      <div class="text-actions">
        <button class="btn-jump">Jump to Page</button>
        <button class="btn-highlight">Highlight</button>
      </div>
    `;
    wrapper.querySelector('.btn-jump').onclick = () => jumpToPage(page);
    wrapper.querySelector('.btn-highlight').onclick = () => highlightText(safeSnippet, page);
    //extractedTextEl.appendChild(wrapper);
  });

  // Background processing (cache embeddings etc.)
  setTimeout(() => {
    fetch('/api/background-process', { method: 'POST' })
      .then(r => r.json())
      .then(d => d.status === 'success' && showNotification('Background processing completed', 'success'))
      .catch(() => showNotification('Background processing failed', 'warning'));
  }, 1500);

  // Insight/Podcast toolbar
  document.getElementById('btn-insights').onclick = () => generateInsights();
  document.getElementById('btn-mic').onclick = () => generatePodcast();

  // Global click: clear selection when clicking outside controls
  document.addEventListener('dblclick', (e) => {
    clearSelectedText();
  });
// Initial render using Adobe Embed API
document.addEventListener("DOMContentLoaded", () => {
  if (res.file_url) {
    initAdobeView(res.file_url);
    console.log(res.file_url, "PDF file URL loaded");
  }
  updateAnnotationCount();
});
  </script>
</body>
</html>